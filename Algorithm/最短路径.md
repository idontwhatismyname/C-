# 最短路径
对于两点i,j的最短路径,要么是直接i到j,要么是i到u,u再到j。  
下列两种就是根据这个思想所写出的方法  
对于最短路径我们有多种算法,首先先介绍我接触到的两种--`dijkstra`和`floyd`。  
首先谈谈两个算法的适用范围,`dijkstra`适合于单源求最短路径,按照我下面未经优化过的思路去写它的时间复杂的是`O(n^2)`。
而对于`floyd`来说,他是多源求最短路径问题,实际上它能求出任意两个点的最短距离,但它的时间复杂度是`O(n^3)`,是一种非常暴力的做法。
## dijkstra
该算法是贪心策略的运用。  
首先我们需要定义两个点集合S和U,S代表着已经走过的点,U代表着还没走过的点,但是是和开始的点是联通的。  
伪代码实现如下：  
```
假设顶点是i  
do{  
    找出U中此时距离顶点最短的的点,记为结点X,那么这时候的dist[i][X]就是最小的(因为剩下的U中的dist都比它大),将其放入集合S  
    假设U上有一点j  
    更新dist[i][j]=min{dist[i][X]+dist[X][j],dist[i][j]}//局部贪心  
}while(U==空集)  
```
## floyd
### 我对于该算法实施的理解
对于任意a,b之间,他们之间存在着多个中间点,他们中间点任意两个之间都是最短路径。  
例如:a->c之间最短路径是a->d->s->e->c,显然d->e的最短路径是d->s->e,否则,a->c之间的最短路径就不是a->d->s->e->c  
再回到算法来看,该算法实际上是一个动态规划的过程,而动态规划重要的是要找到状态方程。  
要对问题进行子结构分析，实际上就是要计算在每一个状态里i和j的最短距离是否被更新，由此我们得到了下列式子  
对于每一个状态k的d[k][i][j](d即是i和j的最短距离)来说，d[k][i][j]=min{d[k-1][i][j],d[k-1][i][k]+d[k-1][k][j]}  
### 我对于算法正确性的理解
虽然我们没有办法保证，对于每个k,d[i][k]和d[k][j]是最小值。  
但是如同上面例子,当k=d时,a到s的距离会是最短,k=e时,s到c的距离会是最短,k=s时，所有的点距离都会是最短。    
当我们以更普遍例子来看,当我们默认存在最短路径,记之为路径s时。若最短路径里有x点,当k=x时,在路径s里,x左右分别在第一次出现比x大的点前的点之间的距离均是他们的最短距离。(这个可以用数学归纳法进行证明)举个例子:a->z->p->q->e->d->s->v->j,当点到e的时候,q->e->d->s这条路径就是最短的。由此递推下去即可。  
所有到最后,我们可以最终通过刷新,在状态方程到最后的时候得到最优的状态。
最后贴上代码具体实现:  
```
for(k=0;k<n;k++)
    for(i=0;i<n;i++)
        for(j=0;j<n;j++)
            if(dist[i][k]+dist[k][j]<dist[i][j])
                dist[i][j]=dist[i][k]+[k][j];
```